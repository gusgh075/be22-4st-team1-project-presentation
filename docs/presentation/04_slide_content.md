[슬라이드 1] 도입: MapLog 프로젝트 개요
[핵심 키워드/내용]
프로젝트명: MapLog
핵심 컨셉: 공간의 맥락을 기록하는 소셜 다이어리
[발표자 스크립트] 안녕하세요. MapLog 팀 발표를 맡은 [이름]입니다. 저희 서비스를 한 문장으로 소개하자면, **"나의 발자취를 지도 위에 기록하고, 친구와 공유하는 위치 기반 소셜 다이어리"**입니다. 기술적 한계를 극복하며 구축한 전체 아키텍처와 치열했던 트러블슈팅 경험을 중심으로 발표를 시작하겠습니다.
[슬라이드 2] 기획 배경 및 문제 정의
[핵심 키워드/내용]
Pain Point: 시간 순 나열 위주의 한계, 공간적 맥락 부재
Solution: 지도를 인터페이스 전면에 배치한 발자취 시각화
[발표자 스크립트] 기존 SNS나 다이어리 앱들은 "언제" 기준의 시간 순 나열에는 강하지만, "어디서"라는 공간적 맥락을 직관적으로 보여주지 못한다는 한계가 있었습니다. 그래서 저희는 지도를 서비스의 전면으로 가져와, 사용자가 지도 위에 핀을 꽂고 발자취를 시각화하며 친구들과 소통할 수 있는 차별화된 경험을 설계했습니다.
[슬라이드 3] 기술 스택 및 서비스 아키텍처
[핵심 키워드/내용]
Frontend: Vue 3 (Composition API), Pinia, Vite
Backend: Spring Boot 3.5, Java 21, MariaDB 11
Infrastructure: Docker, Kubernetes, Jenkins, ArgoCD
[발표자 스크립트] 저희 서비스의 전체적인 아키텍처와 기술 스택입니다. 프론트엔드는 Vue 3의 Composition API와 Pinia를 사용해 상태를 중앙 관리했습니다. 백엔드는 Spring Boot 3.5와 Java 21 기반으로 구축했으며, 특히 인프라 영역에 공을 들여 Docker와 Kubernetes 환경 위에서 Jenkins와 ArgoCD를 결합한 GitOps 방식의 자동 배포 파이프라인을 완성했습니다.
[슬라이드 4] 백엔드 설계: CQRS 패턴 적용
[핵심 키워드/내용]
Command (쓰기): JPA를 통한 강타입 엔티티 관리 및 비즈니스 검증
Query (읽기): MyBatis를 활용한 복잡한 조회 쿼리 최적화
[발표자 스크립트] 백엔드 설계의 핵심은 CQRS(명령과 조회의 책임 분리) 패턴의 도입입니다. 다이어리 도메인의 특성상 쓰기 작업은 연관관계와 검증이 복잡한 반면, 읽기 작업은 화면에 필요한 특정 데이터만 가볍게 가져와야 합니다. 이를 패키지 수준에서 분리하여 쓰기는 JPA로 안정성을 챙기고, 읽기는 MyBatis 등을 통해 부분적으로 최적화하여 시스템 복잡도를 크게 낮췄습니다.
[슬라이드 5] 스토리지 전략: AWS S3 Presigned URL
[핵심 키워드/내용]
통신 흐름: 백엔드를 우회하여 S3로 직접 이미지 요청 (Read 분리)
보안과 성능: 1시간 유효 임시 서명 URL, S3 퍼블릭 차단 유지
[발표자 스크립트] 이미지 파일 저장 시 AWS S3를 연동하며 Presigned URL 방식을 채택했습니다. 백엔드는 업로드 중개자 역할만 수행하며 DB에는 원본 URL을 기록하고, 조회 시마다 1시간 동안만 유효한 임시 서명 URL을 발급해 줍니다. 이를 통해 클라이언트는 서버를 거치지 않고 S3에 직접 이미지를 요청하므로 백엔드의 부하를 없애고, S3 버킷의 퍼블릭 차단 상태를 유지해 보안성도 확보했습니다.
[슬라이드 6] DevOps: GitOps 기반 배포 파이프라인 (CI/CD)
[핵심 키워드/내용]
CI (Jenkins): 소스 빌드 → Docker 이미지 빌드 → Registry Push
CD (ArgoCD): 매니페스트 레포지토리 감지 및 K8s 클러스터 동기화
[발표자 스크립트] 운영 자동화를 위해 Jenkins와 ArgoCD를 결합한 GitOps 배포 모델을 구축했습니다. 개발자가 main 브랜치에 코드를 푸시하면, GitHub Webhook이 터널링을 통해 Jenkins를 트리거하여 빌드 및 Docker Hub 푸시를 수행합니다. 이후 매니페스트가 업데이트되면, K8s 클러스터 내의 ArgoCD가 변경을 감지하여 최신 상태로 자동 동기화하는 배포 파이프라인을 완성했습니다.
[슬라이드 7] 주요 기능 시연 및 실시간 알림 시스템
[핵심 키워드/내용]
기능: 카카오맵 연동 마커 표시 및 일기 피드
실시간 통신: SSE(Server-Sent Events)를 활용한 단방향 푸시 알림
[발표자 스크립트] 카카오 맵 SDK를 직접 제어해 지도 영역 변경 시 화면 내의 마커만 효율적으로 렌더링하고 일기를 기록할 수 있습니다. 친구 추가나 요청 시 발생하는 실시간 알림은 SSE(Server-Sent Events)로 구현했습니다. WebSocket과 달리 HTTP 표준 위에서 동작하기 때문에 별도 프로토콜 업그레이드 없이 기존 보안 설정을 유지하며 가볍게 푸시 알림을 구현할 수 있었습니다.
[슬라이드 8] 트러블슈팅 1: K8s Ingress 80포트 노출 문제
[핵심 키워드/내용]
문제: K8s NodePort의 포트 제한(30000-32767)으로 표준 80포트 접근 불가
해결: NGINX Ingress Controller 도입 및 라우팅 최적화
[발표자 스크립트] 이제 개발 과정에서 겪은 핵심 트러블슈팅 사례입니다. 첫 번째는 K8s 환경에서의 서비스 포트 노출 문제입니다. 서비스 진입점을 표준 HTTP 포트인 80으로 설정하려 했으나, NodePort는 30000번대 이상의 포트만 할당 가능한 물리적 한계가 있었습니다. 이를 극복하기 위해 NGINX Ingress Controller를 클러스터에 도입했고, 호스트의 80포트를 점유하여 내부 서비스로 깔끔하게 라우팅할 수 있었습니다.
[슬라이드 9] 트러블슈팅 2: 인증 안정성 확보 및 API 경로 리팩토링
[핵심 키워드/내용]
인증 갱신: Axios Interceptor 기반 자동 갱신 및 실패 요청 큐(Queue) 처리
경로 최적화: /api/api/ 중복 문제 해결을 위한 공통 URL 중앙화
[발표자 스크립트] 두 번째는 프론트엔드 통신 과정의 최적화입니다. 토큰 만료 시 사용자가 겪는 401 에러를 방지하고자 Axios 인터셉터를 구축했고, 동시에 여러 API가 실패할 때를 대비해 실패 요청들을 큐(Queue)에 쌓아두었다가 Refresh Token 갱신 후 한 번에 재시도하도록 개선했습니다. 또한 API URL에 /api/api/가 중복으로 붙는 현상을 파악하고, 코드 내부의 /api 접두사를 전면 제거하여 환경변수(baseURL)로 일괄 관리되도록 리팩토링했습니다.
[슬라이드 10] 트러블슈팅 3: 환경별 파일 저장 전략 (@Profile)
[핵심 키워드/내용]
문제: 로컬과 K8s 운영 환경 간의 파일 저장소(로컬 파일시스템 vs S3) 차이
해결: @Profile 어노테이션과 전략 패턴을 결합한 동적 구현체 주입
[발표자 스크립트] 세 번째는 파일 저장 전략입니다. 로컬과 운영 서버의 저장소가 달랐는데, if 분기문을 쓰면 비즈니스 로직 안에 인프라 판단이 섞여 복잡해집니다. 저희는 Spring의 @Profile을 활용한 전략 패턴으로 접근했습니다. FileStorageService 인터페이스를 정의하고, 로컬 전용 구현체와 S3 전용 구현체를 분리하여 서비스 코드 단 한 줄의 수정 없이 환경 변수에 따라 구현체가 자동 교체되도록 설계했습니다.
[슬라이드 11] 트러블슈팅 4: K8s 환경 이미지 401 복합 장애 해결
[핵심 키워드/내용]
문제: K8s 배포 후 이미지 로딩 시 브라우저 401 에러 발생
해결: 세 가지 레이어(Profile 설정, 프론트 경로 결합, Security 필터) 분해 검증
[발표자 스크립트] 가장 까다로웠던 복합 장애 사례입니다. K8s 배포 후 이미지가 401 권한 에러로 깨졌는데, 추적 결과 세 개의 독립된 레이어가 맞물린 문제였습니다. 첫째, 환경변수 누락으로 S3 대신 로컬 스토리지가 활성화됐고, 둘째, 프론트엔드 이미지 태그에 API 경로가 잘못 붙어 인증 헤더가 누락되었으며, 셋째, 해당 프록시 경로가 Security 설정에서 막혀 있었습니다. @Profile 매핑을 재설계하고, Presigned URL을 통해 브라우저가 직접 S3에 접근하도록 트래픽 흐름을 수정하여 근본적으로 해결했습니다.
[슬라이드 12] 마무리: 성과 및 향후 발전 방향
[핵심 키워드/내용]
성과: DevOps 라이프사이클 체감 및 레이어 분리 디버깅 사고방식 확보
발전 방향: 방문 장소 통계(히트맵), WebSocket 기반 실시간 위치 공유, PWA
[발표자 스크립트] 이번 프로젝트에서 얻은 가장 큰 수확은 CI/CD 파이프라인을 직접 운영하며 DevOps 전체 흐름을 체감한 것과, 장애 발생 시 원인을 레이어별로 분리해서 분석하는 디버깅 사고방식을 기른 점입니다. 앞으로는 방문 장소 기반 히트맵 시각화와, SSE의 한계를 넘은 WebSocket 기반 실시간 위치 공유를 도입할 계획입니다. 단순한 기록을 넘어, 사용자의 삶의 지도를 완성해가는 MapLog로 계속 발전시켜 나가겠습니다. 감사합니다.